package main

import (
	"fmt"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	"gopkg.in/yaml.v2"
)

type data struct {
	hostname string
	ip       string
	monkey   time.Time
	donkey   time.Time
	chonky   time.Time
	err      string
}

var (
	dataChan  chan data
	mu        *sync.Mutex
	hostIPMap map[string]data
)

type details struct {
	Hostname string `yaml:"hostname"`
	IP       string `yaml:"ip"`
}

func init() {

	var hosts []details
	conf, err := os.ReadFile(`config.yml`)
	if err != nil {
		panic(err)
	}

	if err := yaml.Unmarshal(conf, &hosts); err != nil {
		panic(err)
	}

	for _, h := range hosts {
		fmt.Println("Added", h.Hostname)
		hostIPMap[h.Hostname] = data{hostname: h.Hostname, ip: h.IP, monkey: time.Now().AddDate(0, 0, -1), donkey: time.Now().AddDate(0, 0, -1), chonky: time.Now().AddDate(0, 0, -1)}
	}

}

func getMalwareStatusForHost(ctx *gin.Context) {
	type statusData struct {
		Donkey int `json:"donkey"`
		Monkey int `json:"monkey"`
	}

	hostname := ctx.Param("hostname")

	mu.Lock()
	defer mu.Unlock()

	data, ok := hostIPMap[hostname]
	if !ok {
		fmt.Printf("Unauthorized host %v\n", hostname)
		ctx.AbortWithStatus(http.StatusUnauthorized)
		return
	}

	status := statusData{
		Donkey: int(time.Since(data.donkey) / time.Second),
		Monkey: int(time.Since(data.monkey) / time.Second),
	}

	ctx.JSON(http.StatusOK, status)
}

func setMalwareActiveForHost(ctx *gin.Context) {
	hostname := ctx.Param("hostname")
	malware := ctx.Param("malware")

	mu.Lock()
	defer mu.Unlock()

	data, ok := hostIPMap[hostname]
	if !ok {
		fmt.Printf("Unauthorized host %v\n", hostname)
		ctx.AbortWithStatus(http.StatusUnauthorized)
		return
	}

	switch malware {
	case "chonky":
		data.chonky = time.Now()
	case "monkey":
		data.monkey = time.Now()
	case "donkey":
		data.donkey = time.Now()
	default:
		fmt.Printf("Unauthorized malware %v from host %v\n", malware, hostname)
		ctx.AbortWithStatus(http.StatusUnauthorized)
		return
	}

	hostIPMap[hostname] = data
	dataChan <- data
}

func handleErrorFromHost(ctx *gin.Context) {
	type errMsg struct {
		ErrorMsg string `json:"error"`
	}

	hostname := ctx.Param("hostname")
	malware := ctx.Param("malware")

	var emsg errMsg
	if err := ctx.ShouldBind(&emsg); err != nil {
		fmt.Println(err)
		ctx.AbortWithStatus(http.StatusNotAcceptable)
		return
	}

	mu.Lock()
	defer mu.Unlock()

	data, ok := hostIPMap[hostname]
	if !ok {
		fmt.Printf("Unauthorized host %v\n", hostname)
		ctx.AbortWithStatus(http.StatusUnauthorized)
		return
	}

	switch malware {
	case "chonky":
		data.chonky = time.Now()
		data.err = fmt.Sprintf("chonky:%v", emsg.ErrorMsg)
	case "monkey":
		data.monkey = time.Now()
		data.err = fmt.Sprintf("monkey:%v", emsg.ErrorMsg)
	case "donkey":
		data.donkey = time.Now()
		data.err = fmt.Sprintf("donkey:%v", emsg.ErrorMsg)
	default:
		fmt.Printf("Unauthorized malware %v from host %v\n", malware, hostname)
		ctx.AbortWithStatus(http.StatusUnauthorized)
		return
	}

	hostIPMap[hostname] = data
	dataChan <- data
}

func main() {
	fmt.Println("Starting Jenny")

	mu = new(sync.Mutex)
	dataChan = make(chan data)
	go write(dataChan)

	gin.SetMode(gin.ReleaseMode)
	router := gin.Default()
	router.GET("/api/status/:hostname", getMalwareStatusForHost)
	router.GET("/api/active/:malware/:hostname", setMalwareActiveForHost)
	router.POST("/api/error/:malware/:hostname", handleErrorFromHost)
	router.Run("127.0.0.1:8080")
}

func write(dc <-chan data) {
	f, err := os.OpenFile("./logs", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		panic(err)
	}

	f.Write([]byte(fmt.Sprintf("Started logging at %v\n", strings.Split(time.Now().Format("01-02-2006 15:04:05"), " ")[1])))

	for data := range dc {
		currTime := strings.Split(time.Now().Format("01-02-2006 15:04:05"), " ")[1]
		toPrint := fmt.Sprintf("%v|%15v|%10v|chonky:%15v|monkey:%15v|donkey:%15v|%v|", currTime, data.ip, data.hostname, time.Since(data.chonky), time.Since(data.monkey), time.Since(data.donkey), data.err)

		if _, err := f.Write([]byte(toPrint + "\n")); err != nil {
			fmt.Println(err)
		}

		fmt.Println(toPrint)
	}
}
